[{"title":"GC算法比较","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/GC算法比较/","text":"几种GC算法比较引用计数运行时会记录某个时刻有多少存活对象引用了某个指定对象。当某个对象的引用计数为0时，表示可以回收这个对象。引用计数有一个显著问题，就是循环引用 引用跟踪先将应用程序中所有可见的对象标记为存活的，然后递归标记可以通过存活对象访问的对象 标记清理 标记：将根集合中的一个对象添加到队列中遍历队列中对象，对于每个对象标记为可达，将这个对象所持有的引用添加到队列中 清理：遍历堆中每个对象，如果没有被标记可达则回收 标记和清楚两个过程效率不高会产生大量不连续的内存碎片，分配大对象时容易提前触发GC 复制把可用内存分为大小相等的两块，每次只使用一块，当一块用完时，将存活对象复制到另一块，再一次清理掉一使用的内存块 实现简单，分配快，只需顺序移动堆顶指针就可以进行分配，代价是内存浪费大 分代回收算法综合使用上诉几种算法","tags":[{"name":"GC","slug":"GC","permalink":"http://diinvoke.me/tags/GC/"}]},{"title":"Java数据类型","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/Java数据类型/","text":"Java两大数据类型： 内置类型 引用类型 内置类型共有八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型 byte 8位 -128(-2^7) ~ 127(2^7-1) short 16位 -32768(-2^15) ~ 32767(2^15-1) short数据类型也可以像byte那样节省空间 int 32位 -2147483648(-2^31) ~ 2147485647(2^31 -1) 默认值为0 long 64位 -2^63 ~ 2^63-1 默认值为0L float 单精度浮点数 32位 不能用于表示精确的值 double 双精度浮点数 64位 浮点数的默认类型 同样不能用于表示精确的数 默认值为0.0f boolean 表示一位的信息 true or false 默认值为 false char 是一个单一的16位Unicode字符 最小值为’\\u0000’ (0) 最大值为’\\uffff’ (65535) char数据类型可以存贮任何字符 引用类型 引用类型变量由类的构造函数创建，可以使用他们访问所引用的对象，这些变量在声明时被指定为一个特定的类型，变量一旦声明后，类型就不能改变了。 对象、数组都是引用数据类型 所有引用数据类型的默认值为 null 一个引用变量可以用来引用任何与之兼容的类型 Java常量常量就是一个固定值，不需要计算，直接代表响应的值。常量值不能改变的量，用final标志 1final double PI = 3.1415926","tags":[]},{"title":"Spring AOP 术语","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/Spring AOP术语/","text":"Spring AOP名词解释 切面(Aspect)：切面是通知和切点的结合。通知和切点共同定义了关于切面的全部内容——它是什么，在何时和何处完成其功能 通知(Advice)：切面的目标——它必须要完成的任务。在AOP中切面的工作被称为通知。通知定义了切面是什么以及何时使用。除描述切面要完成的工作，通知还解决了何时执行这个工作的问题。 Spring 切面可以应用5种类型的通知 Before：在方法调用之前 After：在方法完成之后调用通知，无论方法执行是否成功 After-returning：在方法成功执行之后调用通知 After-throwing：在方法抛出异常后调用通知 Around：通知包裹了被通知的方法，在被通知方法调用之前和调用之后执行自定义的行为 连接点：我们的应用可能需要对数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时，抛出异常时，甚至是一个修改字段时。切面的代码可以利用这些点插入到应用的正常流程中，并添加新的行为。 切点：切点有助于缩小切面所通知的连接点的范围。如果通知定义了切面的“什么”和“何时”，那么切点就定义了“何处”。切点的敌营会匹配通知所要植入的一个或多个连接点。我们通常使用明确的类和方法名称来制定这些点，或是利用正则表达式来匹配方法名称。 引入：引入允许我们像现有的类添加新方法或属性 织入：织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标的生命周期有多个点可以织入： 编译时：切面在目标类编译时被织入。需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。 类加载时：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoad），它可以在目标类被引入应用之前增强该目标类的字节码 运行时：切面在应用运行的摸个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP就是以这种方式织入切面的","tags":[{"name":"Spring","slug":"Spring","permalink":"http://diinvoke.me/tags/Spring/"}]},{"title":"hexo+git搭建个人博客","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/hexo+git搭建博客/","text":"前提准备 git node git 配置 git 基本配置 注册一个git账户 新建一个repository 并命名为xxx.github.io(xxx替换为你的用户名，比如我agzdjy.github.io) Node 环境安装 node 环境的配置 hexo 初始化hexo的创建很简单，只需要几个很短的命令即可 进入你想创建hexo项目的目录 执行 1npm install -g hexo-cli 接着 1hexo init 安装一些插件（非必需） 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 测试效果 执行 hexo server启动服务器即可在127.0.0.1:4000上看到效果 主题的替换 从git上 clone相关主题，存放在/themes目录下 配置项目根目录下的_congfig.yml文件，修改theme字段为所clone的主题名 配置主题目录下_config.yml 部署到git上 修改根目录下_config.yml文件 1234deploy: type: git repository: git@github.com:jianghao/jianghao.github.io.git branch: master 执行 hexo d -g 等同于先执行 hexo generate 然后 hexo deploy 其他 可以将一些固定链接的文件比如个人介绍放在/source目录下，然后修改主题配置文件_config.yml来将页面某个链接指向它 参考 Hexo配置 主题文件配置","tags":[]},{"title":"node+mssql+sqlserver","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/node+mssql+sqlserver/","text":"config 举例 var config = { user : &quot;账户名&quot;, password : &quot;密码&quot;, server : &quot;ip&quot;, database : &quot;库名&quot;, pool /*连接池配置*/: { max : 10, min : 1, idleTimeoutMillis : 3000 }, } connecitons 建立连接 var connection = new sql.Connection(/*config*/); 执行查询 connection.connect(function(err){ if(err) console.log(err); else{ var request = new sql.Request(connection); request.query(&apos;/*sql语句*/&apos;, function(err, recordset){ if(err) console.log(err); else{ console.log(recordset); } }) } }); 或者 sql.connect(config, function(err){ if(err) { console.log(err); } else{ var request = new sql.Request(); request.query(&apos;/*sql语句*/&apos;, function(err, recordset) { if(err){ console.log(err); }else{ return res.json(JSON.stringify(recordset)); } });","tags":[]},{"title":"node 单元测试","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/node单元测试/","text":"安装1$ npm install mocha -g 测试用例 BDD(行为驱动开发)风格代码12345678910111213var assert = require(\"assert\");describe('Array', function() &#123; describe('#indexOf()', function() &#123; it('should retuen -1 when the value is not present', function() &#123; assert.equal(-1, [1,2,3].indexOf(5)); assert.equal(-1, [1,2,3].indexOf(0)); &#125;); &#125;)；&#125;);$ mocha1 test complete describe(modulelName, testDetails)describe是可以嵌套的比如上面可以理解成测试Array下的indexOf子模块。modulelName描述测试的内容。 it(info, function)具体的测试语句会放在it回调函数里，info一般会概述期望的正确的输出。一个it对应一个实际的test case. assert.equal(exp1, exp2)断言判断exp1是否等于exp2,是最常用的一个断言 断言断言表示：只要它能抛出错误，那么它就能工作 异步执行的代码用Mocha来测试异步代码同样非常简单，只需要在你的测试结束时调用回调函数即可。通过给it()添加回调函数（通常命名为done）可以告知Mocha需要等待异步测试结束。1234567891011describe('User', function() &#123; describe('#save()', function() &#123; it('should save without error', function(done) &#123; var user = new User('Luna'); user.save(function(err) &#123; if (err) throw err; done(); &#125;); &#125;); &#125;);&#125;); 为了更方便的使用，回调函数done()支持接收一个错误，所以我们可以直接这样来使用它 12345678describe('User', function() &#123; describe('#save()', function() &#123; it('should save without error', function(done) &#123; var user = new User('Luna'); user.save(done); &#125;); &#125;);&#125;); done函数的作用任何一个函数都可以传入一个参数，这个参数是一个回调，用来告知Mocah该函数已经执行结束 所有的钩子（before()、after()、beforeEach()、afterEach()）都同时支持同步和异步，行为表现也类似于通常的测试用例。 before/after：对于定义在describe中before/after，执行这个describe时都执行一次，而无论其中有多少个嵌套的describe或则item(it). 嵌套中如果也定义了before/after，则他们都会被执行，同样是在本describe开始和结束 beforeEach/afterEach：对于定义在describe中的beforeEach/afterEach，则在describe中定义的所有item（包括嵌套的describe中的item）执行前后都会被调用 HTTP API第三方库依赖 supertest 安装命令 npm install supertest -g模拟HTTP GET示例 12345678910111213describe('GET /users', function()&#123; it('get school', function(done)&#123; request(\"http://peter.yunxiao.com\") .get('/user') .query(&#123; itemName : \"school\" &#125;) .expect(200) .end(function(err, data) &#123; if(err) done(err); assert.ok(data.body); done(); &#125;); &#125;);&#125;); 模拟HTTP POST示例1234567891011121314describe('POST /users', function() &#123; it('add user', function(done) &#123; request(\"http://peter.yunxiao.com\") .post(\"/user\") .send(&#123; id:1, name:\"user1\"&#125;) .expect(200) .end(function(err, data) &#123; if(err) done(err); assert.ok(data.body); assert.equal(data.body.code, 1); done(); &#125;); &#125;);&#125;) 超时设置mocha 的默认超时时间为 2000 毫秒。可以通过 mocha -t 来设置所有用例的超时时间。在单个测试用例中，可以通过调用 this.timeout(ms) 来修改当前用例的超时设置，示例如下：1234it('should take less than 500ms', function(done) &#123; this.timeout(500); setTimeout(done, 300);&#125;); 在描述 describe 中调用 this.timeout(ms) 可以设置该描述下当前层级的所有用例的超时时间，示例如下：123456789describe('timeout test', function() &#123; this.timeout(500); it('should take less than 500ms', function(done) &#123; setTimeout(done, 300); &#125;); it('should take less than 500ms', function(done) &#123; setTimeout(done, 200); &#125;);&#125;) 常用断言方法 ok()：判断结果是否为真 equal()：判断实际值与期望值是否相等 notEqual()：判断实际值与期望值是否不相等 deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等） notDeepEqual()：判断实际值与期望值是否不深度相等 strictEqual()：判断实际值与期望值是否严格相等（相当于===） notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==） throws()：判断代码块是否抛出异常 doesNotThrow()：判断代码块是否没有抛出异常 ifError()：判断实际值是否为一个假值（null, undefined, 0, ‘’, false）如果实际值为真值，将会抛出异常 第三方扩展断言库：should.js、expect、chai 等 参考GitHubnpm教程","tags":[]},{"title":"四种常见的POST提交数据方式","date":"2017-04-06T12:57:24.000Z","path":"2017/04/06/四种常见POST提交数据方式/","text":"HTTP/1.1协议规定的HTTP请求方式有OPTIONS、GET、POST、PUT、DELETE、TRACE、CONNECT这几种。其中POST一般用于向服务器提交数据 HTTP协议是以ASCLL码传输的，建立在TCP/IP协议之上的应用层协议。HTTP请求分为：状态行、请求头、消息主体。 协议规定POST提交的数据必须放在消息主体(entity-body)中，但没有规定使用什么编码方式。所以说到POST提交数据方案，包含了Content-Type和消息主体编码方式两部分。 application/x-www-form-urlencoded最常见的POST提交数据的方式。浏览器原生的form表单，如果不设置enctype属性，那么最终就会以application/x-www-form-urlencoded方式提交数据，代码如下1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先Content-Type被指定为application/x-www-form-urlencoded;其次提交的数据按照key1=val1&amp;&amp;key2=val2的方式编码的，key与value都进行的转码 在很多的时候，我们用Ajax提交数据时，也是用这种方式，比如JQuery multipart/form-data当使用表单上传文件时，必须让form的enctyped等于这个值 application/json用来告诉服务端消息主题是序列化后的JSON字符串Google的AngularJS中Ajax功能默认提交JSON字符串使用这种方案可以方便的提交复杂的结构化数据，特别束河RESTful的接口 text/xml它是一种使用HTTP为传输协议，XML作为编码方式的远程调用规范。典型的XML-RPC请求： 123456789101112POST http://www.example.com HTTP/1.1Content-Type: text/xml&lt;?xml version=\"1.0\"?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 参考","tags":[]}]